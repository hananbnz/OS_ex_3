reuveny, hanabnz
Reuven Yimmer (301789947), Hanan Benzion (026606608)
EX: 3

FILES:
Thread.h - the thread object header file
Thread.cpp - the thread object cpp file
uthreads.cpp -- the thread functions library
README(this file)
Makefile - Running make generate the libuthreads.a library

REMARKS:
None.

ANSWERS:
##########################################################################
Q1:
Describe in high level one usage of user-level threads and explain why
user-level threads are reasonable choice for your example (2.5 pts).

One usage of user-level threads is when wanting to control the threads
management of a process.User level-threads allows you to determine a customized
scheduling algorithm for each process(like the Round-Robin algorithm we used in
this exercise). This is a reasonable choice because kernel-level threads
doesn't allow you to set a specific algorithm and the responsibility
for scheduling is only managed by the operating system.(what also causes greater
cost when switch between threads).

Q2:
Google’s Chrome browser creates new process for each tab. What are the
advantages and disadvantaged of creating new process (instead of creating
kernel-level thread)?(2.5 pts)

Advantages
----------
1. Creates a separation between web pages, so when rendering engine crash in one
web app, it won't affect the browser or other web apps.
2. Allows the OS to run web apps in parallel to increase their responsiveness.
3. Runs the rendering engine processes in a restrictive sandbox that limit
 the damage if an exploit does occur.

Disadvantaged
-------------
1. The computer would start to slow down if we created too many processes.
2. If there are a few tabs that share resources. Synchronising
can be more complicated and expensive task(then in kernel-level threads).

Q3:
a. Open an application (for example, Shotwell in CS computers). Use ‘ps –A’
command and extract the application pid (process id).

Shotwell id:30534

b. Open a Shell and type ‘kill pid’.

Shotwell was killed.

c. Explain which interrupts and signals are involved during the command
execution, what triggered them and who should handle them. In your answer refer
to keyboard, OS, shell (in which you type the kill command) and
the application you just killed(2.5 pts).

Before the command execution, the OS managed all the processes and the signals.
Then,we typed the kill command which sent a hardware interrupt from the
keyboard that displays the command in the shell. By pressing the ENTER button
the shell sent another hardware interrupt to the OS to start an interrupt
handler for executing the kill command. The kill command is executed in this way
- the shell sends SIGTERM signal This signal notifies the process to clean
his sources and then end correctly by himself.

Q4:
Real time decrements in real time (wall clock).For example we will use real
time when we want to print a message every few seconds.
where, virtual time decrements only when the process is executing.
means, timer counts down against the user-mode CPU time consumed by the process.
For example in this exercise we used virtual time as quants to measure each
thread running time on CPU (without the waiting time).
